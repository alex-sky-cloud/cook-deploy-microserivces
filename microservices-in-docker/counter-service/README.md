
### Description

   Сервис подсчета запросов. **Request** приходит на сервер. Затем срабатывает _счетчик_
 и результат возвращается клиенту.

Запускаем сборку

    docker image build . -t counter-service:1.0.0

Запускаем создание контейнера и пробрасываем порт

    docker run --tty --detach --name counter_service_container --publish=8081:8081 counter-service:1.0.0

#### Совместный запуск сервисов в Docker

Для начала наши сервисы должны быть в одной сети. В докере существует несколько типов сетей,
и мы используем самый примитивный из них — **bridge**, позволяющий объединять в сеть контейнеры,
запущенные на одном хосте.

- Создадим сеть следующей командой:


    docker network create msvc-network

Далее запустим контейнер  под именем '**backend_counter_service'** с образом counter-service:1.0.0 :

docker run -dit --name backend --network msvc-network counter-service:1.0.0

- -d - запускает контейнер в фоновом режиме;
- -t - прикрепляет к контейнеру псевдо-TTY-консоль;
- -i - выводит в терминал STDIN поток контейнера;
- --name - имя контейнера, по которому потом можно будет к нему обращаться;
- --network - тип сети для контейнера, может принимать такие значения: **bridge** 
(используется по умолчанию), none, host.
Также можно передать идентификатор сети Docker, к которой надо подключится;

##### Стоит отметить, что bridge-сеть предоставляет из коробки service discovery для контейнеров по их именам.


**Запускаем шлюз:**


    docker run -dit -p 80:8080 --env secret=my-real-secret --env BACKEND_URL=http://backend:8080/ --name gateway --network msvc-network msvc-gateway:1.0.0

**80** - это порт снаружи контейнера, он то же HTTP (обращаться к нему нужно как **127.0.0.1** - можно без указания :80)
**8080** - это порт внутри контейнера, он то же HTTP (альтернативный)

После запуска вызываем
**_http://localhost/_**
и убеждаемся, что все работает, как и в прошлом случае.